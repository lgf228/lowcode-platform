// StaticDataManager.ts
// TODO: Update to use new type system from '../types'
// Temporarily keeping old implementation for reference

export default class StaticDataManager {
  private projectTree: ProjectNode | null = null

  // Load project configuration from a JSON file
  async loadProject(projectPath: string): Promise<ProjectNode> {
    const response = await fetch(projectPath)
    this.projectTree = await response.json()
    return this.projectTree!
  }

  // Save project configuration to a JSON file
  async saveProject(project: ProjectNode): Promise<void> {
    this.projectTree = project
    await this.persistToStorage(project)
  }

  // Find a node by its ID
  findNode(id: string): TreeNode | null {
    return this.searchTree(this.projectTree, id)
  }

  // Add a new node under a parent node
  addNode(parentId: string, node: TreeNode): void {
    const parent = this.findNode(parentId)
    if (parent && 'children' in parent && parent.children) {
      parent.children.push(node)
    }
  }

  // Remove a node by its ID
  removeNode(nodeId: string): void {
    this.removeFromTree(this.projectTree, nodeId)
  }

  // Update a node's properties
  updateNode(nodeId: string, updates: Partial<TreeNode>): void {
    const node = this.findNode(nodeId)
    if (node) {
      Object.assign(node, updates)
    }
  }

  // Get the module hierarchy
  getModuleHierarchy(): ModuleHierarchy[] {
    if (!this.projectTree) return []
    return this.buildModuleHierarchy([this.projectTree], 0)
  }

  // Build the module hierarchy recursively
  private buildModuleHierarchy(
    modules: ModuleNode[],
    level: number
  ): ModuleHierarchy[] {
    return modules.map(module => ({
      id: module.id,
      name: module.name,
      level,
      hasChildren: module.children.some(
        child => child.type === 'module' || child.type === 'project'
      ),
      children: this.buildModuleHierarchy(
        module.children.filter(
          child => child.type === 'module' || child.type === 'project'
        ) as ModuleNode[],
        level + 1
      ),
    }))
  }

  // Recursive search for a node in the tree
  private searchTree(node: any, targetId: string): any {
    if (node?.id === targetId) return node
    if (node?.children) {
      for (const child of node.children) {
        const result = this.searchTree(child, targetId)
        if (result) return result
      }
    }
    return null
  }

  // Recursive removal of a node from the tree
  private removeFromTree(node: any, targetId: string): boolean {
    if (node?.children) {
      const index = node.children.findIndex(
        (child: any) => child.id === targetId
      )
      if (index !== -1) {
        node.children.splice(index, 1)
        return true
      }
      for (const child of node.children) {
        if (this.removeFromTree(child, targetId)) {
          return true
        }
      }
    }
    return false
  }

  // Persist project data to storage
  private async persistToStorage(project: ProjectNode): Promise<void> {
    console.log('Saving project to storage:', project)
  }
}

// Module hierarchy interface
interface ModuleHierarchy {
  id: string
  name: string
  level: number
  hasChildren: boolean
  children: ModuleHierarchy[]
}
